"use strict";(self.webpackChunk_actinc_dls=self.webpackChunk_actinc_dls||[]).push([[3890],{"./node_modules/@mui/material/esm/styles/useTheme.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{A:()=>useTheme});var react__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/react/index.js"),_mui_system__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/@mui/system/esm/useTheme/useTheme.js"),_defaultTheme_js__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./node_modules/@mui/material/esm/styles/defaultTheme.js"),_identifier_js__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__("./node_modules/@mui/material/esm/styles/identifier.js");function useTheme(){const theme=(0,_mui_system__WEBPACK_IMPORTED_MODULE_1__.A)(_defaultTheme_js__WEBPACK_IMPORTED_MODULE_2__.A);return react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue(theme),theme[_identifier_js__WEBPACK_IMPORTED_MODULE_3__.A]||theme}},"./node_modules/@mui/system/esm/useThemeProps/getThemeProps.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{A:()=>getThemeProps});var _mui_utils_resolveProps__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/@mui/system/node_modules/@mui/utils/esm/resolveProps/resolveProps.js");function getThemeProps(params){const{theme,name,props}=params;return theme&&theme.components&&theme.components[name]&&theme.components[name].defaultProps?(0,_mui_utils_resolveProps__WEBPACK_IMPORTED_MODULE_0__.A)(theme.components[name].defaultProps,props):props}},"./node_modules/@mui/system/esm/useThemeProps/useThemeProps.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{A:()=>useThemeProps});var _getThemeProps_js__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/@mui/system/esm/useThemeProps/getThemeProps.js"),_useTheme_index_js__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/@mui/system/esm/useTheme/useTheme.js");function useThemeProps({props,name,defaultTheme,themeId}){let theme=(0,_useTheme_index_js__WEBPACK_IMPORTED_MODULE_0__.A)(defaultTheme);return themeId&&(theme=theme[themeId]||theme),(0,_getThemeProps_js__WEBPACK_IMPORTED_MODULE_1__.A)({theme,name,props})}},"./node_modules/@turf/bbox/dist/esm/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{function coordEach(geojson,callback,excludeWrapCoord){if(null!==geojson)for(var j,k,l,geometry,stopG,coords,geometryMaybeCollection,isGeometryCollection,wrapShrink=0,coordIndex=0,type=geojson.type,isFeatureCollection="FeatureCollection"===type,isFeature="Feature"===type,stop=isFeatureCollection?geojson.features.length:1,featureIndex=0;featureIndex<stop;featureIndex++){stopG=(isGeometryCollection=!!(geometryMaybeCollection=isFeatureCollection?geojson.features[featureIndex].geometry:isFeature?geojson.geometry:geojson)&&"GeometryCollection"===geometryMaybeCollection.type)?geometryMaybeCollection.geometries.length:1;for(var geomIndex=0;geomIndex<stopG;geomIndex++){var multiFeatureIndex=0,geometryIndex=0;if(null!==(geometry=isGeometryCollection?geometryMaybeCollection.geometries[geomIndex]:geometryMaybeCollection)){coords=geometry.coordinates;var geomType=geometry.type;switch(wrapShrink=!excludeWrapCoord||"Polygon"!==geomType&&"MultiPolygon"!==geomType?0:1,geomType){case null:break;case"Point":if(!1===callback(coords,coordIndex,featureIndex,multiFeatureIndex,geometryIndex))return!1;coordIndex++,multiFeatureIndex++;break;case"LineString":case"MultiPoint":for(j=0;j<coords.length;j++){if(!1===callback(coords[j],coordIndex,featureIndex,multiFeatureIndex,geometryIndex))return!1;coordIndex++,"MultiPoint"===geomType&&multiFeatureIndex++}"LineString"===geomType&&multiFeatureIndex++;break;case"Polygon":case"MultiLineString":for(j=0;j<coords.length;j++){for(k=0;k<coords[j].length-wrapShrink;k++){if(!1===callback(coords[j][k],coordIndex,featureIndex,multiFeatureIndex,geometryIndex))return!1;coordIndex++}"MultiLineString"===geomType&&multiFeatureIndex++,"Polygon"===geomType&&geometryIndex++}"Polygon"===geomType&&multiFeatureIndex++;break;case"MultiPolygon":for(j=0;j<coords.length;j++){for(geometryIndex=0,k=0;k<coords[j].length;k++){for(l=0;l<coords[j][k].length-wrapShrink;l++){if(!1===callback(coords[j][k][l],coordIndex,featureIndex,multiFeatureIndex,geometryIndex))return!1;coordIndex++}geometryIndex++}multiFeatureIndex++}break;case"GeometryCollection":for(j=0;j<geometry.geometries.length;j++)if(!1===coordEach(geometry.geometries[j],callback,excludeWrapCoord))return!1;break;default:throw new Error("Unknown Geometry Type")}}}}}__webpack_require__.d(__webpack_exports__,{A:()=>turf_bbox_default});var turf_bbox_default=function bbox(geojson,options={}){if(null!=geojson.bbox&&!0!==options.recompute)return geojson.bbox;const result=[1/0,1/0,-1/0,-1/0];return coordEach(geojson,(coord=>{result[0]>coord[0]&&(result[0]=coord[0]),result[1]>coord[1]&&(result[1]=coord[1]),result[2]<coord[0]&&(result[2]=coord[0]),result[3]<coord[1]&&(result[3]=coord[1])})),result}},"./node_modules/ramda/es/equals.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{function _isPlaceholder(a){return null!=a&&"object"==typeof a&&!0===a["@@functional/placeholder"]}function _curry1(fn){return function f1(a){return 0===arguments.length||_isPlaceholder(a)?f1:fn.apply(this,arguments)}}function _curry2(fn){return function f2(a,b){switch(arguments.length){case 0:return f2;case 1:return _isPlaceholder(a)?f2:_curry1((function(_b){return fn(a,_b)}));default:return _isPlaceholder(a)&&_isPlaceholder(b)?f2:_isPlaceholder(a)?_curry1((function(_a){return fn(_a,b)})):_isPlaceholder(b)?_curry1((function(_b){return fn(a,_b)})):fn(a,b)}}}function _arrayFromIterator(iter){for(var next,list=[];!(next=iter.next()).done;)list.push(next.value);return list}function _includesWith(pred,x,list){for(var idx=0,len=list.length;idx<len;){if(pred(x,list[idx]))return!0;idx+=1}return!1}function _has(prop,obj){return Object.prototype.hasOwnProperty.call(obj,prop)}__webpack_require__.d(__webpack_exports__,{A:()=>es_equals});const internal_objectIs="function"==typeof Object.is?Object.is:function _objectIs(a,b){return a===b?0!==a||1/a==1/b:a!=a&&b!=b};var _isArguments_toString=Object.prototype.toString;const internal_isArguments=function(){return"[object Arguments]"===_isArguments_toString.call(arguments)?function _isArguments(x){return"[object Arguments]"===_isArguments_toString.call(x)}:function _isArguments(x){return _has("callee",x)}}();var hasEnumBug=!{toString:null}.propertyIsEnumerable("toString"),nonEnumerableProps=["constructor","valueOf","isPrototypeOf","toString","propertyIsEnumerable","hasOwnProperty","toLocaleString"],hasArgsEnumBug=function(){return arguments.propertyIsEnumerable("length")}(),contains=function contains(list,item){for(var idx=0;idx<list.length;){if(list[idx]===item)return!0;idx+=1}return!1};const es_keys="function"!=typeof Object.keys||hasArgsEnumBug?_curry1((function keys(obj){if(Object(obj)!==obj)return[];var prop,nIdx,ks=[],checkArgsLength=hasArgsEnumBug&&internal_isArguments(obj);for(prop in obj)!_has(prop,obj)||checkArgsLength&&"length"===prop||(ks[ks.length]=prop);if(hasEnumBug)for(nIdx=nonEnumerableProps.length-1;nIdx>=0;)_has(prop=nonEnumerableProps[nIdx],obj)&&!contains(ks,prop)&&(ks[ks.length]=prop),nIdx-=1;return ks})):_curry1((function keys(obj){return Object(obj)!==obj?[]:Object.keys(obj)}));const es_type=_curry1((function type(val){return null===val?"Null":void 0===val?"Undefined":Object.prototype.toString.call(val).slice(8,-1)}));function _uniqContentEquals(aIterator,bIterator,stackA,stackB){var a=_arrayFromIterator(aIterator);function eq(_a,_b){return _equals(_a,_b,stackA.slice(),stackB.slice())}return!_includesWith((function(b,aItem){return!_includesWith(eq,aItem,b)}),_arrayFromIterator(bIterator),a)}function _equals(a,b,stackA,stackB){if(internal_objectIs(a,b))return!0;var typeA=es_type(a);if(typeA!==es_type(b))return!1;if("function"==typeof a["fantasy-land/equals"]||"function"==typeof b["fantasy-land/equals"])return"function"==typeof a["fantasy-land/equals"]&&a["fantasy-land/equals"](b)&&"function"==typeof b["fantasy-land/equals"]&&b["fantasy-land/equals"](a);if("function"==typeof a.equals||"function"==typeof b.equals)return"function"==typeof a.equals&&a.equals(b)&&"function"==typeof b.equals&&b.equals(a);switch(typeA){case"Arguments":case"Array":case"Object":if("function"==typeof a.constructor&&"Promise"===function _functionName(f){var match=String(f).match(/^function (\w*)/);return null==match?"":match[1]}(a.constructor))return a===b;break;case"Boolean":case"Number":case"String":if(typeof a!=typeof b||!internal_objectIs(a.valueOf(),b.valueOf()))return!1;break;case"Date":if(!internal_objectIs(a.valueOf(),b.valueOf()))return!1;break;case"Error":return a.name===b.name&&a.message===b.message;case"RegExp":if(a.source!==b.source||a.global!==b.global||a.ignoreCase!==b.ignoreCase||a.multiline!==b.multiline||a.sticky!==b.sticky||a.unicode!==b.unicode)return!1}for(var idx=stackA.length-1;idx>=0;){if(stackA[idx]===a)return stackB[idx]===b;idx-=1}switch(typeA){case"Map":return a.size===b.size&&_uniqContentEquals(a.entries(),b.entries(),stackA.concat([a]),stackB.concat([b]));case"Set":return a.size===b.size&&_uniqContentEquals(a.values(),b.values(),stackA.concat([a]),stackB.concat([b]));case"Arguments":case"Array":case"Object":case"Boolean":case"Number":case"String":case"Date":case"Error":case"RegExp":case"Int8Array":case"Uint8Array":case"Uint8ClampedArray":case"Int16Array":case"Uint16Array":case"Int32Array":case"Uint32Array":case"Float32Array":case"Float64Array":case"ArrayBuffer":break;default:return!1}var keysA=es_keys(a);if(keysA.length!==es_keys(b).length)return!1;var extendedStackA=stackA.concat([a]),extendedStackB=stackB.concat([b]);for(idx=keysA.length-1;idx>=0;){var key=keysA[idx];if(!_has(key,b)||!_equals(b[key],a[key],extendedStackA,extendedStackB))return!1;idx-=1}return!0}const es_equals=_curry2((function equals(a,b){return _equals(a,b,[],[])}))},"./node_modules/react-map-gl/dist/mapbox.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{z0:()=>AttributionControl,T3:()=>FullscreenControl,tG:()=>GeolocateControl,Wd:()=>Layer,T5:()=>map_Map,pH:()=>Marker,ov:()=>NavigationControl,zD:()=>Popup,g0:()=>ScaleControl,kL:()=>Source});var react=__webpack_require__("./node_modules/react/index.js");const MountedMapsContext=react.createContext(null);function deepEqual(a,b){if(a===b)return!0;if(!a||!b)return!1;if(Array.isArray(a)){if(!Array.isArray(b)||a.length!==b.length)return!1;for(let i=0;i<a.length;i++)if(!deepEqual(a[i],b[i]))return!1;return!0}if(Array.isArray(b))return!1;if("object"==typeof a&&"object"==typeof b){const aKeys=Object.keys(a),bKeys=Object.keys(b);if(aKeys.length!==bKeys.length)return!1;for(const key of aKeys){if(!b.hasOwnProperty(key))return!1;if(!deepEqual(a[key],b[key]))return!1}return!0}return!1}function syncProjection(src,dest){if(!src.getProjection)return;const srcProjection=src.getProjection();deepEqual(srcProjection,dest.getProjection())||dest.setProjection(srcProjection)}function transformToViewState(tr){return{longitude:tr.center.lng,latitude:tr.center.lat,zoom:tr.zoom,pitch:tr.pitch,bearing:tr.bearing,padding:tr.padding}}function applyViewStateToTransform(tr,props){const v=props.viewState||props;let changed=!1;if("zoom"in v){const zoom=tr.zoom;tr.zoom=v.zoom,changed=changed||zoom!==tr.zoom}if("bearing"in v){const bearing=tr.bearing;tr.bearing=v.bearing,changed=changed||bearing!==tr.bearing}if("pitch"in v){const pitch=tr.pitch;tr.pitch=v.pitch,changed=changed||pitch!==tr.pitch}if(v.padding&&!tr.isPaddingEqual(v.padding)&&(changed=!0,tr.padding=v.padding),"longitude"in v&&"latitude"in v){const center=tr.center;tr.center=new center.constructor(v.longitude,v.latitude),changed=changed||center!==tr.center}return changed}const refProps=["type","source","source-layer","minzoom","maxzoom","filter","layout"];function normalizeStyle(style){if(!style)return null;if("string"==typeof style)return style;if("toJS"in style&&(style=style.toJS()),!style.layers)return style;const layerIndex={};for(const layer of style.layers)layerIndex[layer.id]=layer;const layers=style.layers.map((layer=>{let normalizedLayer=null;"interactive"in layer&&(normalizedLayer=Object.assign({},layer),delete normalizedLayer.interactive);const layerRef=layerIndex[layer.ref];if(layerRef){normalizedLayer=normalizedLayer||Object.assign({},layer),delete normalizedLayer.ref;for(const propName of refProps)propName in layerRef&&(normalizedLayer[propName]=layerRef[propName])}return normalizedLayer||layer}));return{...style,layers}}const DEFAULT_STYLE={version:8,sources:{},layers:[]},pointerEvents={mousedown:"onMouseDown",mouseup:"onMouseUp",mouseover:"onMouseOver",mousemove:"onMouseMove",click:"onClick",dblclick:"onDblClick",mouseenter:"onMouseEnter",mouseleave:"onMouseLeave",mouseout:"onMouseOut",contextmenu:"onContextMenu",touchstart:"onTouchStart",touchend:"onTouchEnd",touchmove:"onTouchMove",touchcancel:"onTouchCancel"},cameraEvents={movestart:"onMoveStart",move:"onMove",moveend:"onMoveEnd",dragstart:"onDragStart",drag:"onDrag",dragend:"onDragEnd",zoomstart:"onZoomStart",zoom:"onZoom",zoomend:"onZoomEnd",rotatestart:"onRotateStart",rotate:"onRotate",rotateend:"onRotateEnd",pitchstart:"onPitchStart",pitch:"onPitch",pitchend:"onPitchEnd"},otherEvents={wheel:"onWheel",boxzoomstart:"onBoxZoomStart",boxzoomend:"onBoxZoomEnd",boxzoomcancel:"onBoxZoomCancel",resize:"onResize",load:"onLoad",render:"onRender",idle:"onIdle",remove:"onRemove",data:"onData",styledata:"onStyleData",sourcedata:"onSourceData",error:"onError"},settingNames=["minZoom","maxZoom","minPitch","maxPitch","maxBounds","projection","renderWorldCopies"],handlerNames=["scrollZoom","boxZoom","dragRotate","dragPan","keyboard","doubleClickZoom","touchZoomRotate","touchPitch"];class Mapbox{constructor(MapClass,props,container){this._map=null,this._internalUpdate=!1,this._inRender=!1,this._hoveredFeatures=null,this._deferredEvents={move:!1,zoom:!1,pitch:!1,rotate:!1},this._onEvent=e=>{const cb=this.props[otherEvents[e.type]];cb?cb(e):"error"===e.type&&console.error(e.error)},this._onPointerEvent=e=>{"mousemove"!==e.type&&"mouseout"!==e.type||this._updateHover(e);const cb=this.props[pointerEvents[e.type]];cb&&(this.props.interactiveLayerIds&&"mouseover"!==e.type&&"mouseout"!==e.type&&(e.features=this._hoveredFeatures||this._queryRenderedFeatures(e.point)),cb(e),delete e.features)},this._onCameraEvent=e=>{if(!this._internalUpdate){const cb=this.props[cameraEvents[e.type]];cb&&cb(e)}e.type in this._deferredEvents&&(this._deferredEvents[e.type]=!1)},this._MapClass=MapClass,this.props=props,this._initialize(container)}get map(){return this._map}get transform(){return this._renderTransform}setProps(props){const oldProps=this.props;this.props=props;const settingsChanged=this._updateSettings(props,oldProps);settingsChanged&&this._createShadowTransform(this._map);const sizeChanged=this._updateSize(props),viewStateChanged=this._updateViewState(props,!0);this._updateStyle(props,oldProps),this._updateStyleComponents(props,oldProps),this._updateHandlers(props,oldProps),(settingsChanged||sizeChanged||viewStateChanged&&!this._map.isMoving())&&this.redraw()}static reuse(props,container){const that=Mapbox.savedMaps.pop();if(!that)return null;const map=that.map,oldContainer=map.getContainer();for(container.className=oldContainer.className;oldContainer.childNodes.length>0;)container.appendChild(oldContainer.childNodes[0]);map._container=container,that.setProps({...props,styleDiffing:!1}),map.resize();const{initialViewState}=props;return initialViewState&&(initialViewState.bounds?map.fitBounds(initialViewState.bounds,{...initialViewState.fitBoundsOptions,duration:0}):that._updateViewState(initialViewState,!1)),map.isStyleLoaded()?map.fire("load"):map.once("styledata",(()=>map.fire("load"))),map._update(),that}_initialize(container){const{props}=this,{mapStyle=DEFAULT_STYLE}=props,mapOptions={...props,...props.initialViewState,accessToken:props.mapboxAccessToken||getAccessTokenFromEnv()||null,container,style:normalizeStyle(mapStyle)},viewState=mapOptions.initialViewState||mapOptions.viewState||mapOptions;if(Object.assign(mapOptions,{center:[viewState.longitude||0,viewState.latitude||0],zoom:viewState.zoom||0,pitch:viewState.pitch||0,bearing:viewState.bearing||0}),props.gl){const getContext=HTMLCanvasElement.prototype.getContext;HTMLCanvasElement.prototype.getContext=()=>(HTMLCanvasElement.prototype.getContext=getContext,props.gl)}const map=new this._MapClass(mapOptions);viewState.padding&&map.setPadding(viewState.padding),props.cursor&&(map.getCanvas().style.cursor=props.cursor),this._createShadowTransform(map);const renderMap=map._render;map._render=arg=>{this._inRender=!0,renderMap.call(map,arg),this._inRender=!1};const runRenderTaskQueue=map._renderTaskQueue.run;map._renderTaskQueue.run=arg=>{runRenderTaskQueue.call(map._renderTaskQueue,arg),this._onBeforeRepaint()},map.on("render",(()=>this._onAfterRepaint()));const fireEvent=map.fire;map.fire=this._fireEvent.bind(this,fireEvent),map.on("resize",(()=>{this._renderTransform.resize(map.transform.width,map.transform.height)})),map.on("styledata",(()=>{this._updateStyleComponents(this.props,{}),syncProjection(map.transform,this._renderTransform)})),map.on("sourcedata",(()=>this._updateStyleComponents(this.props,{})));for(const eventName in pointerEvents)map.on(eventName,this._onPointerEvent);for(const eventName in cameraEvents)map.on(eventName,this._onCameraEvent);for(const eventName in otherEvents)map.on(eventName,this._onEvent);this._map=map}recycle(){const children=this.map.getContainer().querySelector("[mapboxgl-children]");children?.remove(),Mapbox.savedMaps.push(this)}destroy(){this._map.remove()}redraw(){const map=this._map;!this._inRender&&map.style&&(map._frame&&(map._frame.cancel(),map._frame=null),map._render())}_createShadowTransform(map){const renderTransform=function cloneTransform(tr){const newTransform=tr.clone();return newTransform.pixelsToGLUnits=tr.pixelsToGLUnits,newTransform}(map.transform);map.painter.transform=renderTransform,this._renderTransform=renderTransform}_updateSize(nextProps){const{viewState}=nextProps;if(viewState){const map=this._map;if(viewState.width!==map.transform.width||viewState.height!==map.transform.height)return map.resize(),!0}return!1}_updateViewState(nextProps,triggerEvents){if(this._internalUpdate)return!1;const map=this._map,tr=this._renderTransform,{zoom,pitch,bearing}=tr,isMoving=map.isMoving();isMoving&&(tr.cameraElevationReference="sea");const changed=applyViewStateToTransform(tr,{...transformToViewState(map.transform),...nextProps});if(isMoving&&(tr.cameraElevationReference="ground"),changed&&triggerEvents){const deferredEvents=this._deferredEvents;deferredEvents.move=!0,deferredEvents.zoom||(deferredEvents.zoom=zoom!==tr.zoom),deferredEvents.rotate||(deferredEvents.rotate=bearing!==tr.bearing),deferredEvents.pitch||(deferredEvents.pitch=pitch!==tr.pitch)}return isMoving||applyViewStateToTransform(map.transform,nextProps),changed}_updateSettings(nextProps,currProps){const map=this._map;let changed=!1;for(const propName of settingNames)if(propName in nextProps&&!deepEqual(nextProps[propName],currProps[propName])){changed=!0;const setter=map[`set${propName[0].toUpperCase()}${propName.slice(1)}`];setter?.call(map,nextProps[propName])}return changed}_updateStyle(nextProps,currProps){if(nextProps.cursor!==currProps.cursor&&(this._map.getCanvas().style.cursor=nextProps.cursor||""),nextProps.mapStyle!==currProps.mapStyle){const{mapStyle=DEFAULT_STYLE,styleDiffing=!0}=nextProps,options={diff:styleDiffing};return"localIdeographFontFamily"in nextProps&&(options.localIdeographFontFamily=nextProps.localIdeographFontFamily),this._map.setStyle(normalizeStyle(mapStyle),options),!0}return!1}_updateStyleComponents(nextProps,currProps){const map=this._map;let changed=!1;return map.isStyleLoaded()&&("light"in nextProps&&map.setLight&&!deepEqual(nextProps.light,currProps.light)&&(changed=!0,map.setLight(nextProps.light)),"fog"in nextProps&&map.setFog&&!deepEqual(nextProps.fog,currProps.fog)&&(changed=!0,map.setFog(nextProps.fog)),"terrain"in nextProps&&map.setTerrain&&!deepEqual(nextProps.terrain,currProps.terrain)&&(nextProps.terrain&&!map.getSource(nextProps.terrain.source)||(changed=!0,map.setTerrain(nextProps.terrain)))),changed}_updateHandlers(nextProps,currProps){const map=this._map;let changed=!1;for(const propName of handlerNames){const newValue=nextProps[propName]??!0;deepEqual(newValue,currProps[propName]??!0)||(changed=!0,newValue?map[propName].enable(newValue):map[propName].disable())}return changed}_queryRenderedFeatures(point){const map=this._map,tr=map.transform,{interactiveLayerIds=[]}=this.props;try{return map.transform=this._renderTransform,map.queryRenderedFeatures(point,{layers:interactiveLayerIds.filter(map.getLayer.bind(map))})}catch{return[]}finally{map.transform=tr}}_updateHover(e){const{props}=this;if(props.interactiveLayerIds&&(props.onMouseMove||props.onMouseEnter||props.onMouseLeave)){const eventType=e.type,wasHovering=this._hoveredFeatures?.length>0,features=this._queryRenderedFeatures(e.point),isHovering=features.length>0;!isHovering&&wasHovering&&(e.type="mouseleave",this._onPointerEvent(e)),this._hoveredFeatures=features,isHovering&&!wasHovering&&(e.type="mouseenter",this._onPointerEvent(e)),e.type=eventType}else this._hoveredFeatures=null}_fireEvent(baseFire,event,properties){const map=this._map,tr=map.transform,eventType="string"==typeof event?event:event.type;return"move"===eventType&&this._updateViewState(this.props,!1),eventType in cameraEvents&&("object"==typeof event&&(event.viewState=transformToViewState(tr)),this._map.isMoving())?(map.transform=this._renderTransform,baseFire.call(map,event,properties),map.transform=tr,map):(baseFire.call(map,event,properties),map)}_onBeforeRepaint(){const map=this._map;this._internalUpdate=!0;for(const eventType in this._deferredEvents)this._deferredEvents[eventType]&&map.fire(eventType);this._internalUpdate=!1;const tr=this._map.transform;map.transform=this._renderTransform,this._onAfterRepaint=()=>{syncProjection(this._renderTransform,tr),map.transform=tr}}}Mapbox.savedMaps=[];const mapbox_mapbox=Mapbox;function getAccessTokenFromEnv(){let accessToken=null;if("undefined"!=typeof location){const match=/access_token=([^&\/]*)/.exec(location.search);accessToken=match&&match[1]}try{accessToken=accessToken||process.env.MapboxAccessToken}catch{}try{accessToken=accessToken||process.env.REACT_APP_MAPBOX_ACCESS_TOKEN}catch{}return accessToken}const skipMethods=["setMaxBounds","setMinZoom","setMaxZoom","setMinPitch","setMaxPitch","setRenderWorldCopies","setProjection","setStyle","addSource","removeSource","addLayer","removeLayer","setLayerZoomRange","setFilter","setPaintProperty","setLayoutProperty","setLight","setTerrain","setFog","remove"];function createRef(mapInstance){if(!mapInstance)return null;const map=mapInstance.map,ref={getMap:()=>map,getCenter:()=>mapInstance.transform.center,getZoom:()=>mapInstance.transform.zoom,getBearing:()=>mapInstance.transform.bearing,getPitch:()=>mapInstance.transform.pitch,getPadding:()=>mapInstance.transform.padding,getBounds:()=>mapInstance.transform.getBounds(),project:lnglat=>{const tr=map.transform;map.transform=mapInstance.transform;const result=map.project(lnglat);return map.transform=tr,result},unproject:point=>{const tr=map.transform;map.transform=mapInstance.transform;const result=map.unproject(point);return map.transform=tr,result},queryTerrainElevation:(lnglat,options)=>{const tr=map.transform;map.transform=mapInstance.transform;const result=map.queryTerrainElevation(lnglat,options);return map.transform=tr,result},queryRenderedFeatures:(geometry,options)=>{const tr=map.transform;map.transform=mapInstance.transform;const result=map.queryRenderedFeatures(geometry,options);return map.transform=tr,result}};for(const key of function getMethodNames(obj){const result=new Set;let proto=obj;for(;proto;){for(const key of Object.getOwnPropertyNames(proto))"_"!==key[0]&&"function"==typeof obj[key]&&"fire"!==key&&"setEventedParent"!==key&&result.add(key);proto=Object.getPrototypeOf(proto)}return Array.from(result)}(map))key in ref||skipMethods.includes(key)||(ref[key]=map[key].bind(map));return ref}const use_isomorphic_layout_effect="undefined"!=typeof document?react.useLayoutEffect:react.useEffect,globalSettings=["baseApiUrl","maxParallelImageRequests","workerClass","workerCount","workerUrl"];const map_MapContext=react.createContext(null);const map_Map=react.forwardRef((function _Map(props,ref){const mountedMapsContext=(0,react.useContext)(MountedMapsContext),[mapInstance,setMapInstance]=(0,react.useState)(null),containerRef=(0,react.useRef)(),{current:contextValue}=(0,react.useRef)({mapLib:null,map:null});(0,react.useEffect)((()=>{const mapLib=props.mapLib;let mapbox,isMounted=!0;return Promise.resolve(mapLib||__webpack_require__.e(842).then(__webpack_require__.t.bind(__webpack_require__,"./node_modules/mapbox-gl/dist/mapbox-gl.js",23))).then((module=>{if(!isMounted)return;if(!module)throw new Error("Invalid mapLib");const mapboxgl="Map"in module?module:module.default;if(!mapboxgl.Map)throw new Error("Invalid mapLib");!function setGlobals(mapLib,props){for(const key of globalSettings)key in props&&(mapLib[key]=props[key]);const{RTLTextPlugin="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-rtl-text/v0.2.3/mapbox-gl-rtl-text.js"}=props;RTLTextPlugin&&mapLib.getRTLTextPluginStatus&&"unavailable"===mapLib.getRTLTextPluginStatus()&&mapLib.setRTLTextPlugin(RTLTextPlugin,(error=>{error&&console.error(error)}),!0)}(mapboxgl,props),props.reuseMaps&&(mapbox=mapbox_mapbox.reuse(props,containerRef.current)),mapbox||(mapbox=new mapbox_mapbox(mapboxgl.Map,props,containerRef.current)),contextValue.map=createRef(mapbox),contextValue.mapLib=mapboxgl,setMapInstance(mapbox),mountedMapsContext?.onMapMount(contextValue.map,props.id)})).catch((error=>{const{onError}=props;onError?onError({type:"error",target:null,error}):console.error(error)})),()=>{isMounted=!1,mapbox&&(mountedMapsContext?.onMapUnmount(props.id),props.reuseMaps?mapbox.recycle():mapbox.destroy())}}),[]),use_isomorphic_layout_effect((()=>{mapInstance&&mapInstance.setProps(props)})),(0,react.useImperativeHandle)(ref,(()=>contextValue.map),[mapInstance]);const style=(0,react.useMemo)((()=>({position:"relative",width:"100%",height:"100%",...props.style})),[props.style]);return react.createElement("div",{id:props.id,ref:containerRef,style},mapInstance&&react.createElement(map_MapContext.Provider,{value:contextValue},react.createElement("div",{"mapboxgl-children":"",style:{height:"100%"}},props.children)))}));var react_dom=__webpack_require__("./node_modules/react-dom/index.js");const unitlessNumber=/box|flex|grid|column|lineHeight|fontWeight|opacity|order|tabSize|zIndex/;function applyReactStyle(element,styles){if(!element||!styles)return;const style=element.style;for(const key in styles){const value=styles[key];Number.isFinite(value)&&!unitlessNumber.test(key)?style[key]=`${value}px`:style[key]=value}}function compareClassNames(prevClassName,nextClassName){if(prevClassName===nextClassName)return null;const prevClassList=getClassList(prevClassName),nextClassList=getClassList(nextClassName),diff=[];for(const c of nextClassList)prevClassList.has(c)||diff.push(c);for(const c of prevClassList)nextClassList.has(c)||diff.push(c);return 0===diff.length?null:diff}function getClassList(className){return new Set(className?className.trim().split(/\s+/):[])}const Marker=(0,react.memo)((0,react.forwardRef)(((props,ref)=>{const{map,mapLib}=(0,react.useContext)(map_MapContext),thisRef=(0,react.useRef)({props}),marker=(0,react.useMemo)((()=>{let hasChildren=!1;react.Children.forEach(props.children,(el=>{el&&(hasChildren=!0)}));const options={...props,element:hasChildren?document.createElement("div"):null},mk=new mapLib.Marker(options);return mk.setLngLat([props.longitude,props.latitude]),mk.getElement().addEventListener("click",(e=>{thisRef.current.props.onClick?.({type:"click",target:mk,originalEvent:e})})),mk.on("dragstart",(e=>{const evt=e;evt.lngLat=marker.getLngLat(),thisRef.current.props.onDragStart?.(evt)})),mk.on("drag",(e=>{const evt=e;evt.lngLat=marker.getLngLat(),thisRef.current.props.onDrag?.(evt)})),mk.on("dragend",(e=>{const evt=e;evt.lngLat=marker.getLngLat(),thisRef.current.props.onDragEnd?.(evt)})),mk}),[]);(0,react.useEffect)((()=>(marker.addTo(map.getMap()),()=>{marker.remove()})),[]);const{longitude,latitude,offset,style,draggable=!1,popup=null,rotation=0,rotationAlignment="auto",pitchAlignment="auto"}=props;(0,react.useEffect)((()=>{applyReactStyle(marker.getElement(),style)}),[style]),(0,react.useImperativeHandle)(ref,(()=>marker),[]);const oldProps=thisRef.current.props;marker.getLngLat().lng===longitude&&marker.getLngLat().lat===latitude||marker.setLngLat([longitude,latitude]),offset&&!function arePointsEqual(a,b){const ax=Array.isArray(a)?a[0]:a?a.x:0,ay=Array.isArray(a)?a[1]:a?a.y:0,bx=Array.isArray(b)?b[0]:b?b.x:0,by=Array.isArray(b)?b[1]:b?b.y:0;return ax===bx&&ay===by}(marker.getOffset(),offset)&&marker.setOffset(offset),marker.isDraggable()!==draggable&&marker.setDraggable(draggable),marker.getRotation()!==rotation&&marker.setRotation(rotation),marker.getRotationAlignment()!==rotationAlignment&&marker.setRotationAlignment(rotationAlignment),marker.getPitchAlignment()!==pitchAlignment&&marker.setPitchAlignment(pitchAlignment),marker.getPopup()!==popup&&marker.setPopup(popup);const classNameDiff=compareClassNames(oldProps.className,props.className);if(classNameDiff)for(const c of classNameDiff)marker.toggleClassName(c);return thisRef.current.props=props,(0,react_dom.createPortal)(props.children,marker.getElement())}))),Popup=(0,react.memo)((0,react.forwardRef)(((props,ref)=>{const{map,mapLib}=(0,react.useContext)(map_MapContext),container=(0,react.useMemo)((()=>document.createElement("div")),[]),thisRef=(0,react.useRef)({props}),popup=(0,react.useMemo)((()=>{const options={...props},pp=new mapLib.Popup(options);return pp.setLngLat([props.longitude,props.latitude]),pp.once("open",(e=>{thisRef.current.props.onOpen?.(e)})),pp}),[]);if((0,react.useEffect)((()=>{const onClose=e=>{thisRef.current.props.onClose?.(e)};return popup.on("close",onClose),popup.setDOMContent(container).addTo(map.getMap()),()=>{popup.off("close",onClose),popup.isOpen()&&popup.remove()}}),[]),(0,react.useEffect)((()=>{applyReactStyle(popup.getElement(),props.style)}),[props.style]),(0,react.useImperativeHandle)(ref,(()=>popup),[]),popup.isOpen()){const oldProps=thisRef.current.props;popup.getLngLat().lng===props.longitude&&popup.getLngLat().lat===props.latitude||popup.setLngLat([props.longitude,props.latitude]),props.offset&&!deepEqual(oldProps.offset,props.offset)&&(popup.options.anchor=props.anchor,popup.setOffset(props.offset)),oldProps.anchor===props.anchor&&oldProps.maxWidth===props.maxWidth||popup.setMaxWidth(props.maxWidth);const classNameDiff=compareClassNames(oldProps.className,props.className);if(classNameDiff)for(const c of classNameDiff)popup.toggleClassName(c);thisRef.current.props=props}return(0,react_dom.createPortal)(props.children,container)})));function useControl(onCreate,arg1,arg2,arg3){const context=(0,react.useContext)(map_MapContext),ctrl=(0,react.useMemo)((()=>onCreate(context)),[]);return(0,react.useEffect)((()=>{const opts=arg3||arg2||arg1,onAdd="function"==typeof arg1&&"function"==typeof arg2?arg1:null,onRemove="function"==typeof arg2?arg2:"function"==typeof arg1?arg1:null,{map}=context;return map.hasControl(ctrl)||(map.addControl(ctrl,opts?.position),onAdd&&onAdd(context)),()=>{onRemove&&onRemove(context),map.hasControl(ctrl)&&map.removeControl(ctrl)}}),[]),ctrl}const AttributionControl=(0,react.memo)((function _AttributionControl(props){const ctrl=useControl((({mapLib})=>new mapLib.AttributionControl(props)),{position:props.position});return(0,react.useEffect)((()=>{applyReactStyle(ctrl._container,props.style)}),[props.style]),null}));const FullscreenControl=(0,react.memo)((function _FullscreenControl(props){const ctrl=useControl((({mapLib})=>new mapLib.FullscreenControl({container:props.containerId&&document.getElementById(props.containerId)})),{position:props.position});return(0,react.useEffect)((()=>{applyReactStyle(ctrl._controlContainer,props.style)}),[props.style]),null}));const GeolocateControl=(0,react.memo)((0,react.forwardRef)((function _GeolocateControl(props,ref){const thisRef=(0,react.useRef)({props}),ctrl=useControl((({mapLib})=>{const gc=new mapLib.GeolocateControl(props),setupUI=gc._setupUI.bind(gc);return gc._setupUI=args=>{gc._container.hasChildNodes()||setupUI(args)},gc.on("geolocate",(e=>{thisRef.current.props.onGeolocate?.(e)})),gc.on("error",(e=>{thisRef.current.props.onError?.(e)})),gc.on("outofmaxbounds",(e=>{thisRef.current.props.onOutOfMaxBounds?.(e)})),gc.on("trackuserlocationstart",(e=>{thisRef.current.props.onTrackUserLocationStart?.(e)})),gc.on("trackuserlocationend",(e=>{thisRef.current.props.onTrackUserLocationEnd?.(e)})),gc}),{position:props.position});return thisRef.current.props=props,(0,react.useImperativeHandle)(ref,(()=>ctrl),[]),(0,react.useEffect)((()=>{applyReactStyle(ctrl._container,props.style)}),[props.style]),null})));const NavigationControl=(0,react.memo)((function _NavigationControl(props){const ctrl=useControl((({mapLib})=>new mapLib.NavigationControl(props)),{position:props.position});return(0,react.useEffect)((()=>{applyReactStyle(ctrl._container,props.style)}),[props.style]),null}));const ScaleControl=(0,react.memo)((function _ScaleControl(props){const ctrl=useControl((({mapLib})=>new mapLib.ScaleControl(props)),{position:props.position}),propsRef=(0,react.useRef)(props),prevProps=propsRef.current;propsRef.current=props;const{style}=props;return void 0!==props.maxWidth&&props.maxWidth!==prevProps.maxWidth&&(ctrl.options.maxWidth=props.maxWidth),void 0!==props.unit&&props.unit!==prevProps.unit&&ctrl.setUnit(props.unit),(0,react.useEffect)((()=>{applyReactStyle(ctrl._container,style)}),[style]),null}));function assert(condition,message){if(!condition)throw new Error(message)}let sourceCounter=0;function Source(props){const map=(0,react.useContext)(map_MapContext).map.getMap(),propsRef=(0,react.useRef)(props),[,setStyleLoaded]=(0,react.useState)(0),id=(0,react.useMemo)((()=>props.id||"jsx-source-"+sourceCounter++),[]);(0,react.useEffect)((()=>{if(map){const forceUpdate=()=>setTimeout((()=>setStyleLoaded((version=>version+1))),0);return map.on("styledata",forceUpdate),forceUpdate(),()=>{if(map.off("styledata",forceUpdate),map.style&&map.style._loaded&&map.getSource(id)){const allLayers=map.getStyle()?.layers;if(allLayers)for(const layer of allLayers)layer.source===id&&map.removeLayer(layer.id);map.removeSource(id)}}}}),[map]);let source=map&&map.style&&map.getSource(id);return source?function updateSource(source,props,prevProps){assert(props.id===prevProps.id,"source id changed"),assert(props.type===prevProps.type,"source type changed");let changedKey="",changedKeyCount=0;for(const key in props)"children"===key||"id"===key||deepEqual(prevProps[key],props[key])||(changedKey=key,changedKeyCount++);if(!changedKeyCount)return;const type=props.type;"geojson"===type?source.setData(props.data):"image"===type?source.updateImage({url:props.url,coordinates:props.coordinates}):"setCoordinates"in source&&1===changedKeyCount&&"coordinates"===changedKey?source.setCoordinates(props.coordinates):"setUrl"in source&&"url"===changedKey?source.setUrl(props.url):"setTiles"in source&&"tiles"===changedKey?source.setTiles(props.tiles):console.warn(`Unable to update <Source> prop: ${changedKey}`)}(source,props,propsRef.current):source=function createSource(map,id,props){if(map.style&&map.style._loaded){const options={...props};return delete options.id,delete options.children,map.addSource(id,options),map.getSource(id)}return null}(map,id,props),propsRef.current=props,source&&react.Children.map(props.children,(child=>child&&(0,react.cloneElement)(child,{source:id})))||null}let layerCounter=0;function Layer(props){const map=(0,react.useContext)(map_MapContext).map.getMap(),propsRef=(0,react.useRef)(props),[,setStyleLoaded]=(0,react.useState)(0),id=(0,react.useMemo)((()=>props.id||"jsx-layer-"+layerCounter++),[]);(0,react.useEffect)((()=>{if(map){const forceUpdate=()=>setStyleLoaded((version=>version+1));return map.on("styledata",forceUpdate),forceUpdate(),()=>{map.off("styledata",forceUpdate),map.style&&map.style._loaded&&map.getLayer(id)&&map.removeLayer(id)}}}),[map]);if(map&&map.style&&map.getLayer(id))try{!function updateLayer(map,id,props,prevProps){if(assert(props.id===prevProps.id,"layer id changed"),assert(props.type===prevProps.type,"layer type changed"),"custom"===props.type||"custom"===prevProps.type)return;const{layout={},paint={},filter,minzoom,maxzoom,beforeId}=props;if(beforeId!==prevProps.beforeId&&map.moveLayer(id,beforeId),layout!==prevProps.layout){const prevLayout=prevProps.layout||{};for(const key in layout)deepEqual(layout[key],prevLayout[key])||map.setLayoutProperty(id,key,layout[key]);for(const key in prevLayout)layout.hasOwnProperty(key)||map.setLayoutProperty(id,key,void 0)}if(paint!==prevProps.paint){const prevPaint=prevProps.paint||{};for(const key in paint)deepEqual(paint[key],prevPaint[key])||map.setPaintProperty(id,key,paint[key]);for(const key in prevPaint)paint.hasOwnProperty(key)||map.setPaintProperty(id,key,void 0)}deepEqual(filter,prevProps.filter)||map.setFilter(id,filter),minzoom===prevProps.minzoom&&maxzoom===prevProps.maxzoom||map.setLayerZoomRange(id,minzoom,maxzoom)}(map,id,props,propsRef.current)}catch(error){console.warn(error)}else!function createLayer(map,id,props){if(map.style&&map.style._loaded&&(!("source"in props)||map.getSource(props.source))){const options={...props,id};delete options.beforeId,map.addLayer(options,props.beforeId)}}(map,id,props);return propsRef.current=props,null}}}]);