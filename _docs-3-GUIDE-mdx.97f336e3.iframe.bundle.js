"use strict";(self.webpackChunk_actinc_dls=self.webpackChunk_actinc_dls||[]).push([[3278],{"./node_modules/@mdx-js/react/lib/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{R:()=>useMDXComponents,x:()=>MDXProvider});var react__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/react/index.js"),react__WEBPACK_IMPORTED_MODULE_0___default=__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);const emptyComponents={},MDXContext=react__WEBPACK_IMPORTED_MODULE_0___default().createContext(emptyComponents);function useMDXComponents(components){const contextComponents=react__WEBPACK_IMPORTED_MODULE_0___default().useContext(MDXContext);return react__WEBPACK_IMPORTED_MODULE_0___default().useMemo(function(){return"function"==typeof components?components(contextComponents):{...contextComponents,...components}},[contextComponents,components])}function MDXProvider(properties){let allComponents;return allComponents=properties.disableParentContext?"function"==typeof properties.components?properties.components(emptyComponents):properties.components||emptyComponents:useMDXComponents(properties.components),react__WEBPACK_IMPORTED_MODULE_0___default().createElement(MDXContext.Provider,{value:allComponents},properties.children)}},"./src/_docs/3.GUIDE.mdx":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{default:()=>MDXContent});__webpack_require__("./node_modules/react/index.js");var jsx_runtime=__webpack_require__("./node_modules/react/jsx-runtime.js"),lib=__webpack_require__("./node_modules/@mdx-js/react/lib/index.js"),blocks=__webpack_require__("./node_modules/@storybook/addon-docs/dist/blocks.mjs");const GUIDEraw_namespaceObject="# Developer Guide\n\nThis developer guide outlines the core principles that you should keep in mind\nin order to build effectively for the DLS.\n\n## Decouple Business Logic from Render Logic\n\nDLS components are maximally flexible and useful when they are decoupled from\nbusiness logic, API calls, and stylistic assumptions from a particular\napplication or use-case.\n\n```jsx\n// BAD:\n\nconst DlsComponent = () => {\n  const { response } = fetch(...);\n  const arrayOfItems = response.items;\n\n  return (\n    // do something with arrayOfItems\n  );\n};\n\nconst ProjectComponent = () => (\n  <DlsComponent />\n);\n```\n\nFor that reason, DLS components should be as \"dumb\" as possible. Ideally, they\nmerely render based on a set of generic props that are passed in via the\ndownstream project.\n\n```jsx\n// GOOD:\n\nconst DlsComponent = ({ items }) => (\n  // do something with items\n);\n\nconst ProjectComponent = () => {\n  const { response } = fetch(...);\n  const arrayOfItems = response.items;\n\n  return (\n    <DlsComponent items={arrayOfItems} />\n  );\n};\n```\n\n## Be Technology Agnostic\n\nDLS components should work equally well, regardless of the downstream project's\nrender strategy (e.g. SSR vs. Static), state management solution (e.g. React\nContext vs. Redux), framework (e.g. Next.js vs. Create React App), routing\nlibrary (e.g. React Router vs. Next Routes), or network layer\n(e.g. Apollo Client vs. Fetch).\n\nSimply put, the DLS components should make 0 assumptions about the technologies\nbeing used by the downstream project, aside from one special exception:\n[Material UI](https://mui.com/).\n\n## Material UI\n\nThe DLS is based on [Material UI](https://mui.com/) â€” one of the most\npopular and robust component libraries that exists today in the React\necosystem.\n\n[Material UI](https://mui.com/) is integral to the way the DLS functions\n(namely, the theme system), and thus is the only technological requirement that\nis forced upon downstream projects.\n\nIn order to build effectively for the DLS, you really need to know\n[Material UI](https://mui.com/). So if you're not already, become\nfamiliar with the components (and their APIs) that are offered by the library.\n\n(It is also important to understand how to style components using\n[`styled`](https://mui.com/system/styled/), and how to do so in a\ndynamic way using [themes](https://mui.com/customization/theming/). But\nwe'll touch on these items later in the guide!)\n\n### Use Material UI Components Over Native DOM Elements\n\nWhen writing components for the DLS, you should always prefer to use Material UI\ncomponents over native DOM elements.\n\n- If you're building a list (`ul`, `ol`, `li`), use\n  [`List`](https://mui.com/api/list/) and\n  [`ListItem`](https://mui.com/api/list-item/).\n\n- If you're writing text (`h1...h6`, `p`, `span`), use\n  [`Typography`](https://mui.com/api/typography/#typography-api).\n\n- If you need a button or input field (`button`, `input`, `textarea`), use\n  [`Button`](https://mui.com/api/button/#button-api) and\n  [`TextField`](https://mui.com/api/text-field/#textfield-api).\n\nWhenever you find yourself writing a native DOM element, stop and ask yourself:\n\"Is there a suitable alternative provided by the Material UI library?\"\n(hint: usually, there is!)\n\nWhy is this so important? Themes!\n\n### Themes\n\nThe DLS makes full use of Material UI's\n[theme system](https://mui.com/material-ui/customization/theming/). You can\nthink of a theme as a CSS stylesheet that gets injected into the browser\nand dictates how the Material UI components that we use will look and feel.\n\nThe DLS currently supports\n[several different themes](https://github.com/act-org/dls/tree/master/src/styles):\n\n1. `\"ACT\"`: for ACT's \"traditional\" look and feel\n2. `\"ACT_ET\"`: for ACT's \"Emerging Technology\" look and feel\n3. `\"ENCOURA\"`: for the Encoura's \"MyEncoura\" look and feel\n4. `\"ENCOURA_CLASSIC\"`: for Encoura's \"Classic\" look and feel\n5. `\"ENCOURAGE\"`: for the Encoura's \"Encourage for Students\" look and feel\n6. `\"ENCOURAGE_E4E\"`: for the Encoura's \"Encourage for Educators\" look and feel\n\n#### Decouple Style from Functionality\n\nThemes allow us to separate the way a component functions from the way the\ncomponent looks and feels. For example, the\n[`Button`](https://mui.com/material-ui/api/button/#button-api) component from\nMaterial UI has certain core functionality, such as having a label, firing\nevents, and being enabled or disabled. This functionality must exist regardless\nof the appearance of the button.\n\nUsing themes, we can take this core functionality and style it multiple\ndifferent ways:\n\n![Style vs. Functionality](https://user-images.githubusercontent.com/4974609/151506765-5158b283-636c-42ba-b51a-ffb77996252a.png)\n\nThemes are the keystone that enable us to share common functionality\n(components) across different projects that have a completely different\nlook and feel. And this is why you should always prefer to use Material UI\nprimitives over native DOM elements â€” the theme flows throughout all Material\nUI building blocks. This is not the case for native DOM elements.\n\n## Creating a Custom Component\n\nYou can create a new DLS component by creating a folder (using ProperCase)\ninside `src/components`. Each component folder should abide by the following\nstructure:\n\n```sh\nðŸ“‚ components\n â”£ ðŸ“‚ NewComponent\n â”ƒ â”£ index.stories.tsx           // storybook stories go here\n â”ƒ â”£ index.test.tsx              // component tests go here\n â”ƒ â”£ index.tsx                   // component functionality goes here\n â”ƒ â”— styles.ts                   // component custom styles go here\n â”— index.ts\n```\n\nEnsure that all prop types and components are exported from the component's\n`index.tsx` file:\n\n```tsx\n// src/components/NewComponent/index.tsx\n\n// Ensure that the main prop type can be imported by the downstream project.\n// To be consistent with the way Material UI names their prop types, the name\n// of the main prop type should be the name of the component, followed\n// by \"Props\".\nexport type NewComponentProps = { ... };\n\n// Ensure that the main component can be imported by the downstream project\n// using a named import statement.\nexport const NewComponent = () => { ... };\n\n// Ensure that the main component can be imported by the downstream project\n// using a default import statement.\nexport default NewComponent;\n```\n\nAlso, don't forget to also export this component from `src/components/index.ts`:\n\n```ts\n// src/components/index.ts\n\n...\nexport * from './NewComponent';\n...\n```\n\n## Styling a Custom Component\n\nWhen building a custom component, you can usually avoid the need to add custom\nstyles simply by using Material UI primitives over native DOM elements. The\nMaterial UI components are designed to look great out of the box and to\ncompose well together, so definitely use them!\n\nHowever, this does not completely eliminate the need for custom styling, and\nthus at some point you'll need to add a few custom styles to your `styles.ts`\nfile using [`styled`](https://mui.com/system/styled/).\n\n### Avoid Hard Coding\n\nWhen it comes to defining custom styles, the number one rule is to avoid\nhard coding values. When a style value is hard coded, we are making a strong\nopinion that this style should be applied globally for this component across all\nthemes. Often times, this is not the right assumption to make.\n\n```tsx\nimport { styled } from '@actinc/dls/helpers/material/styled';\n\n// BAD: These style values are hard-coded.\nexport const StyledDiv = styled('div')({\n  backgroundColor: '#FFFFFF',\n  borderRadius: 4,\n  boxShadow:\n    '0px 2px 1px -1px rgba(0, 0, 0, 0.2), 0px 1px 1px 0px rgba(0, 0, 0, 0.14), 0px 1px 3px 0px rgba(0, 0, 0, 0.12)',\n  padding: 16,\n});\n\nexport const StyledSpan = styled('span')({\n  fontFamily: 'Museo',\n  fontSize: 10,\n});\n\n// This component is using native DOM elements when there are suitable\n// counterparts in the Material UI library.\nconst NewComponent = () => (\n  <StyledDiv>\n    <StyledSpan>Hello World</StyledSpan>\n  </StyledDiv>\n);\n```\n\nInstead, create dynamic styles by tapping into the theme. This will allow this\ncomponent to look and feel differently across themes!\n\n(To learn about the values that are available to you on the theme object,\nsee [here](https://mui.com/material-ui/customization/theming/) and\n[here](https://mui.com/material-ui/customization/default-theme/).)\n\n```tsx\nimport { styled } from '@actinc/dls/helpers/material/styled';\n\n// BETTER: These style values are dynamic based on the theme.\nexport const StyledDiv = styled('div')(({ theme }) => ({\n  backgroundColor: theme.palette.background.paper,\n  borderRadius: theme.shape.borderRadius,\n  boxShadow: theme.shadows[1],\n  padding: theme.spacing(2),\n}));\n\nexport const StyledSpan = styled('span')(({ theme }) => ({\n  fontFamily: theme.typography.fontFamily,\n  fontSize: theme.typography.caption.fontSize,\n}));\n\n// But this component is still using native DOM elements when there are suitable\n// counterparts in the Material UI library.\nconst MyComponent = () => (\n  <StyledDiv>\n    <StyledSpan>Hello World</StyledSpan>\n  </StyledDiv>\n);\n```\n\nWhen our custom components are built using Material UI primitives, often times\nthe custom styles are no longer needed!\n\n```tsx\nimport { styled } from '@actinc/dls/helpers/material/styled';\n\n// BEST: No custom styles are needed because this component is built using\n// Material UI primitives. We can handle everything using a few simple props!\nconst MyComponent = () => (\n  <Paper elevation={1}>\n    <Typography variant=\"caption\">Hello World</Typography>\n  </Paper>\n);\n```\n";function _createMdxContent(props){return(0,jsx_runtime.jsxs)(jsx_runtime.Fragment,{children:[(0,jsx_runtime.jsx)(blocks.W8,{title:"DLS/Developer Guide"}),"\n",(0,jsx_runtime.jsx)(blocks.oz,{children:GUIDEraw_namespaceObject})]})}function MDXContent(props={}){const{wrapper:MDXLayout}={...(0,lib.R)(),...props.components};return MDXLayout?(0,jsx_runtime.jsx)(MDXLayout,{...props,children:(0,jsx_runtime.jsx)(_createMdxContent,{...props})}):_createMdxContent()}}}]);